# Update modularity gain matrix
for ( k in 1:n ) {
if ( k != best_i && k != best_j ) {
if ( community_map[ k ] != ci ) {
gain_ik <- modularity_gain[ min( best_i, k ), max( best_i, k ) ]
gain_jk <- modularity_gain[ min( best_j, k ), max( best_j, k ) ]
modularity_gain[ min( best_i, k ), max( best_i, k ) ] <- gain_ik + gain_jk
}
}
}
# Invalidate old entries for best_j
modularity_gain[ , best_j ] <- 0
modularity_gain[ best_j, ] <- 0
}
# Extract communities from final community_map
final_communities <- split( 1:n, community_map )
final_communities <- unique( final_communities )
return( list(
modularity = current_modularity,
communities = final_communities
) )
}
# Adjacency matrix
A <- matrix( c(
0, 1, 1, 0, 0, 0,
1, 0, 1, 0, 0, 0,
1, 1, 0, 0, 0, 0,
0, 0, 0, 0, 1, 1,
0, 0, 0, 1, 0, 1,
0, 0, 0, 1, 1, 0
), nrow = 6, byrow = TRUE )
result <- greedy_modularity_fast( A )
cat( "Modularity:", result$modularity, "\n" )
print( result$communities )
adj_matrix <- A
n <- nrow( adj_matrix )
m <- sum( adj_matrix ) / 2
communities <- as.list( 1:n )
communities
# Community degrees and internal link counts
community_degree <- rowSums( adj_matrix )
community_map <- 1:n
# Initialize modularity matrix
modularity_gain <- matrix( 0, n, n )
for ( i in 1:(n - 1) ) {
for ( j in (i + 1):n ) {
if ( adj_matrix[ i, j ] > 0 ) {
ki <- community_degree[ i ]
kj <- community_degree[ j ]
modularity_gain[ i, j ] <- ( adj_matrix[ i, j ] - ( ki * kj ) / ( 2 * m ) ) / m
}
}
}
modularity_gain
generate_block_graph <- function( n = 100, p_in = 0.3, p_out = 0.01 ) {
A <- matrix( 0, nrow = n, ncol = n )
block_size <- n / 2
for ( i in 1:( n - 1 ) ) {
for ( j in ( i + 1 ):n ) {
same_block <- ( i <= block_size && j <= block_size ) || ( i > block_size && j > block_size )
prob <- if ( same_block ) p_in else p_out
edge <- rbinom( 1, 1, prob )
A[ i, j ] <- edge
A[ j, i ] <- edge
}
}
A
}
result <- greedy_modularity_fast( A )
cat( "Modularity:", result$modularity, "\n" )
print( result$communities )
a
A
generate_block_graph <- function( n = 100, p_in = 0.3, p_out = 0.01 ) {
A <- matrix( 0, nrow = n, ncol = n )
block_size <- n / 2
for ( i in 1:( n - 1 ) ) {
for ( j in ( i + 1 ):n ) {
same_block <- ( i <= block_size && j <= block_size ) || ( i > block_size && j > block_size )
prob <- if ( same_block ) p_in else p_out
edge <- rbinom( 1, 1, prob )
A[ i, j ] <- edge
A[ j, i ] <- edge
}
}
A
}
A
generate_block_graph <- function( n = 100, p_in = 0.3, p_out = 0.01 ) {
A <- matrix( 0, nrow = n, ncol = n )
block_size <- n / 2
for ( i in 1:( n - 1 ) ) {
for ( j in ( i + 1 ):n ) {
same_block <- ( i <= block_size && j <= block_size ) || ( i > block_size && j > block_size )
prob <- if ( same_block ) p_in else p_out
edge <- rbinom( 1, 1, prob )
A[ i, j ] <- edge
A[ j, i ] <- edge
}
}
A
}
set.seed(42)
A <- generate_block_graph( n = 100, p_in = 0.3, p_out = 0.01 )
result <- greedy_modularity_fast( A )
cat( "Modularity:", result$modularity, "\n" )
cat( "Number of communities detected:", length( result$communities ), "\n" )
generate_block_graph <- function( n = 500, p_in = 0.3, p_out = 0.01 ) {
A <- matrix( 0, nrow = n, ncol = n )
block_size <- n / 2
for ( i in 1:( n - 1 ) ) {
for ( j in ( i + 1 ):n ) {
same_block <- ( i <= block_size && j <= block_size ) || ( i > block_size && j > block_size )
prob <- if ( same_block ) p_in else p_out
edge <- rbinom( 1, 1, prob )
A[ i, j ] <- edge
A[ j, i ] <- edge
}
}
A
}
set.seed(42)
A <- generate_block_graph( n = 500, p_in = 0.3, p_out = 0.01 )
result <- greedy_modularity_fast( A )
cat( "Modularity:", result$modularity, "\n" )
cat( "Number of communities detected:", length( result$communities ), "\n" )
result
generate_block_graph <- function( n = 500, p_in = 0.3, p_out = 0.11 ) {
A <- matrix( 0, nrow = n, ncol = n )
block_size <- n / 2
for ( i in 1:( n - 1 ) ) {
for ( j in ( i + 1 ):n ) {
same_block <- ( i <= block_size && j <= block_size ) || ( i > block_size && j > block_size )
prob <- if ( same_block ) p_in else p_out
edge <- rbinom( 1, 1, prob )
A[ i, j ] <- edge
A[ j, i ] <- edge
}
}
A
}
set.seed(42)
A <- generate_block_graph( n = 500, p_in = 0.3, p_out = 0.01 )
result <- greedy_modularity_fast( A )
cat( "Modularity:", result$modularity, "\n" )
cat( "Number of communities detected:", length( result$communities ), "\n" )
result
greedy_modularity_fixed <- function( adj_matrix ) {
if ( !is.matrix( adj_matrix ) || nrow( adj_matrix ) != ncol( adj_matrix ) ) {
stop( "Input must be a square adjacency matrix." )
}
n <- nrow( adj_matrix )
m <- sum( adj_matrix ) / 2
degrees <- rowSums( adj_matrix )
# Start with each node in its own community
communities <- lapply( 1:n, function( i ) i )
# Precompute all edge weights between nodes
edge_weights <- adj_matrix
# Initialize community-level edge sums
get_community_degree <- function( comm ) sum( degrees[ comm ] )
compute_modularity <- function( comms ) {
Q <- 0
for ( c in comms ) {
for ( i in c ) {
for ( j in c ) {
Aij <- edge_weights[ i, j ]
Q <- Q + ( Aij - ( degrees[ i ] * degrees[ j ] ) / ( 2 * m ) )
}
}
}
Q / ( 2 * m )
}
current_modularity <- compute_modularity( communities )
improved <- TRUE
while ( improved ) {
best_increase <- -Inf
best_pair <- NULL
for ( i in seq_along( communities ) ) {
for ( j in seq_along( communities ) ) {
if ( i < j ) {
ci <- communities[[ i ]]
cj <- communities[[ j ]]
# Calculate modularity gain from merging ci and cj
ki <- get_community_degree( ci )
kj <- get_community_degree( cj )
eij <- sum( edge_weights[ ci, cj ] )
delta_Q <- ( eij - ( ki * kj ) / ( 2 * m ) ) / m
if ( delta_Q > best_increase ) {
best_increase <- delta_Q
best_pair <- c( i, j )
}
}
}
}
if ( !is.null( best_pair ) && best_increase > 0 ) {
i <- best_pair[1]
j <- best_pair[2]
# Merge communities
new_comm <- c( communities[[ i ]], communities[[ j ]] )
communities <- communities[ -c( i, j ) ]
communities[[ length( communities ) + 1 ]] <- new_comm
# Recompute modularity
current_modularity <- compute_modularity( communities )
} else {
improved <- FALSE
}
}
return( list(
modularity = current_modularity,
communities = communities
) )
}
# Create a 100-node block graph with clear communities
set.seed(42)
A <- generate_block_graph( n = 100, p_in = 0.3, p_out = 0.01 )
result <- greedy_modularity_fixed( A )
cat( "Modularity:", result$modularity, "\n" )
cat( "Number of communities detected:", length( result$communities ), "\n" )
# Create a 100-node block graph with clear communities
set.seed(42)
A <- generate_block_graph( n = 100, p_in = 0.3, p_out = 0.01 )
result <- greedy_modularity_fixed( A )
cat( "Modularity:", result$modularity, "\n" )
cat( "Number of communities detected:", length( result$communities ), "\n" )
# Create a 100-node block graph with clear communities
set.seed(42)
A <- generate_block_graph( n = 100, p_in = 0.3, p_out = 0.01 )
result <- greedy_modularity_fixed( A )
cat( "Modularity:", result$modularity, "\n" )
cat( "Number of communities detected:", length( result$communities ), "\n" )
# Create a 100-node block graph with clear communities
set.seed(42)
A <- generate_block_graph( n = 100, p_in = 0.3, p_out = 0.01 )
result <- greedy_modularity_fixed( A )
cat( "Modularity:", result$modularity, "\n" )
cat( "Number of communities detected:", length( result$communities ), "\n" )
# Create a 100-node block graph with clear communities
A <- generate_block_graph( n = 100, p_in = 0.3, p_out = 0.01 )
result <- greedy_modularity_fixed( A )
cat( "Modularity:", result$modularity, "\n" )
cat( "Number of communities detected:", length( result$communities ), "\n" )
# Create a 100-node block graph with clear communities
A <- generate_block_graph( n = 100, p_in = 0.3, p_out = 0.01 )
result <- greedy_modularity_fixed( A )
cat( "Modularity:", result$modularity, "\n" )
cat( "Number of communities detected:", length( result$communities ), "\n" )
# Create a 100-node block graph with clear communities
A <- generate_block_graph( n = 100, p_in = 0.3, p_out = 0.01 )
result <- greedy_modularity_fixed( A )
cat( "Modularity:", result$modularity, "\n" )
cat( "Number of communities detected:", length( result$communities ), "\n" )
# Create a 100-node block graph with clear communities
A <- generate_block_graph( n = 100, p_in = 0.3, p_out = 0.01 )
result <- greedy_modularity_fixed( A )
cat( "Modularity:", result$modularity, "\n" )
cat( "Number of communities detected:", length( result$communities ), "\n" )
# Create a 100-node block graph with clear communities
A <- generate_block_graph( n = 200, p_in = 0.3, p_out = 0.01 )
result <- greedy_modularity_fixed( A )
cat( "Modularity:", result$modularity, "\n" )
cat( "Number of communities detected:", length( result$communities ), "\n" )
# Create a 100-node block graph with clear communities
A <- generate_block_graph( n = 200, p_in = 0.3, p_out = 0.01 )
result <- greedy_modularity_fixed( A )
cat( "Modularity:", result$modularity, "\n" )
cat( "Number of communities detected:", length( result$communities ), "\n" )
# Create a 100-node block graph with clear communities
A <- generate_block_graph( n = 200, p_in = 0.3, p_out = 0.01 )
result <- greedy_modularity_fixed( A )
cat( "Modularity:", result$modularity, "\n" )
cat( "Number of communities detected:", length( result$communities ), "\n" )
# Create a 100-node block graph with clear communities
A <- generate_block_graph( n = 200, p_in = 0.3, p_out = 0.01 )
result <- greedy_modularity_fixed( A )
cat( "Modularity:", result$modularity, "\n" )
cat( "Number of communities detected:", length( result$communities ), "\n" )
greedy_modularity <- function( adj_matrix ) {
if ( !is.matrix( adj_matrix ) || nrow( adj_matrix ) != ncol( adj_matrix ) ) {
stop( "Input must be a square adjacency matrix." )
}
n <- nrow( adj_matrix )
m <- sum( adj_matrix ) / 2
degrees <- rowSums( adj_matrix )
# Start with each node in its own community
communities <- lapply( 1:n, function( i ) i )
compute_modularity <- function( comms ) {
Q <- 0
for ( c in comms ) {
for ( i in c ) {
for ( j in c ) {
Aij <- adj_matrix[ i, j ]
Q <- Q + ( Aij - ( degrees[ i ] * degrees[ j ] ) / ( 2 * m ) )
}
}
}
Q / ( 2 * m )
}
current_modularity <- compute_modularity( communities )
improved <- TRUE
while ( improved ) {
best_increase <- -Inf
best_merge <- NULL
for ( i in seq_along( communities ) ) {
for ( j in seq_along( communities ) ) {
if ( i < j ) {
merged <- c(
communities[ -c( i, j ) ],
list( c( communities[[ i ]], communities[[ j ]] ) )
)
new_modularity <- compute_modularity( merged )
increase <- new_modularity - current_modularity
# Build synthetic graph
A <- generate_block_graph( n = 100, p_in = 0.3, p_out = 0.01 )
result <- greedy_modularity( A )
cat( "Modularity:", result$modularity, "\n" )
cat( "Number of communities detected:", length( result$communities ), "\n" )
greedy_modularity <- function( adj_matrix ) {
if ( !is.matrix( adj_matrix ) || nrow( adj_matrix ) != ncol( adj_matrix ) ) {
stop( "Input must be a square adjacency matrix." )
}
n <- nrow( adj_matrix )
m <- sum( adj_matrix ) / 2
degrees <- rowSums( adj_matrix )
# Start with each node in its own community
communities <- lapply( 1:n, function( i ) i )
compute_modularity <- function( comms ) {
Q <- 0
for ( c in comms ) {
for ( i in c ) {
for ( j in c ) {
Aij <- adj_matrix[ i, j ]
Q <- Q + ( Aij - ( degrees[ i ] * degrees[ j ] ) / ( 2 * m ) )
}
}
}
Q / ( 2 * m )
}
current_modularity <- compute_modularity( communities )
improved <- TRUE
while ( improved ) {
best_increase <- -Inf
best_merge <- NULL
for ( i in seq_along( communities ) ) {
for ( j in seq_along( communities ) ) {
if ( i < j ) {
merged <- c(
communities[ -c( i, j ) ],
list( c( communities[[ i ]], communities[[ j ]] ) )
)
new_modularity <- compute_modularity( merged )
increase <- new_modularity - current_modularity
if ( increase > best_increase ) {
best_increase <- increase
best_merge <- merged
}
}
}
}
if ( !is.null( best_merge ) && best_increase > 0 ) {
communities <- best_merge
current_modularity <- current_modularity + best_increase
} else {
improved <- FALSE
}
}
return( list(
modularity = current_modularity,
communities = communities
) )
}
# Build synthetic graph
A <- generate_block_graph( n = 100, p_in = 0.3, p_out = 0.01 )
result <- greedy_modularity( A )
greedy_modularity_optimized <- function( adj_matrix ) {
if ( !is.matrix( adj_matrix ) || nrow( adj_matrix ) != ncol( adj_matrix ) ) {
stop( "Input must be a square adjacency matrix." )
}
n <- nrow( adj_matrix )
m <- sum( adj_matrix ) / 2
degrees <- rowSums( adj_matrix )
# Each node starts in its own community
communities <- lapply( 1:n, function( i ) i )
# Compute the degree of each initial community
comm_degrees <- sapply( communities, function( c ) sum( degrees[ c ] ) )
# Compute internal edge sums (should be 0 initially)
comm_internal <- rep( 0, length( communities ) )
compute_modularity <- function( comms, comm_degrees, comm_internal ) {
Q <- 0
for ( k in seq_along( comms ) ) {
Lc <- comm_internal[ k ]
Dc <- comm_degrees[ k ]
Q <- Q + ( Lc / m - ( Dc / ( 2 * m ) )^2 )
}
Q
}
# Initial modularity (zero, all internal edges = 0)
current_modularity <- compute_modularity( communities, comm_degrees, comm_internal )
improved <- TRUE
while ( improved ) {
best_increase <- -Inf
best_i <- -1
best_j <- -1
for ( i in seq_along( communities ) ) {
for ( j in ( i + 1 ):length( communities ) ) {
ci <- communities[[ i ]]
cj <- communities[[ j ]]
# Edges between ci and cj
eij <- sum( adj_matrix[ ci, cj ] )
if ( eij == 0 ) next
ki <- comm_degrees[ i ]
kj <- comm_degrees[ j ]
Li <- comm_internal[ i ]
Lj <- comm_internal[ j ]
# Compute modularity gain using efficient formula
delta_Q <- ( ( Li + Lj + 2 * eij ) / m - ( ( ki + kj ) / ( 2 * m ) )^2 ) -
( Li / m - ( ki / ( 2 * m ) )^2 ) -
( Lj / m - ( kj / ( 2 * m ) )^2 )
if ( delta_Q > best_increase ) {
best_increase <- delta_Q
best_i <- i
best_j <- j
}
}
}
if ( best_increase > 0 ) {
# Merge best_i and best_j
new_comm <- c( communities[[ best_i ]], communities[[ best_j ]] )
new_degree <- comm_degrees[ best_i ] + comm_degrees[ best_j ]
new_internal <- comm_internal[ best_i ] + comm_internal[ best_j ] + 2 * sum( adj_matrix[ communities[[ best_i ]], communities[[ best_j ]] ] )
# Update communities, degrees, and internal edges
keep <- setdiff( seq_along( communities ), c( best_i, best_j ) )
communities <- c( communities[ keep ], list( new_comm ) )
comm_degrees <- c( comm_degrees[ keep ], new_degree )
comm_internal <- c( comm_internal[ keep ], new_internal )
current_modularity <- current_modularity + best_increase
} else {
improved <- FALSE
}
}
return( list(
modularity = current_modularity,
communities = communities
) )
}
set.seed(42)
A <- generate_block_graph( n = 100, p_in = 0.3, p_out = 0.01 )
rm( list = ls() )
library( xml2 )
library( dplyr )
getwd()
rm( list = ls() )
setwd( "/Users/jyoung20/GitHub/TAWR2" )
library( xml2 )
library( dplyr )
xml_doc <- read_xml( "data/drama/hamlet.xml"  )
xml_doc
View(xml_doc)
xml_doc[1]
xml_doc[[1]]
speakers_ns <- xml_find_all( xml_doc, ".//SPEAKER" )
speakers_ns
speaker_names_v <- xml_text( speakers_ns )
spaker_names_v
speaker_names_v
unique(speaker_names_v)
sort( table( speaker_names_v ), decreasing = TRUE )
sort(
table( speaker_names_v ) / length( speakers_ns ) ,
decreasing = TRUE
)
speeches_ns <- xml_find_all( xml_doc, ".//SPEECH" )
speeches_ns
get_pairing <- function( node ){
speaker_v <- xml_text( xml_find_all( node, "SPEAKER" ) )
receiver_v <- xml_text( xml_find_all( node, "RECEIVER" ) )
paste( speaker_v, " -> ", receiver_v )
}
pairings_l <- lapply( speeches_ns, get_pairing )
pairings_l
pairs_v <- unlist( pairings_l )
pairs_v
pairings_df <- data.frame( table( pairs_v ) )
pairings_df
sort(pairings_df)
sort(pairings_df[1])
sort(pairings_df[,1])
pairings_df
arrange( pairings_df, desc( Freq ) )
get_pairing <- function( node ){
speaker_v <- xml_text( xml_find_all( node, "SPEAKER" ) )
receiver_v <- xml_text( xml_find_all( node, "RECEIVER" ) )
lines_v <- paste(
xml_text( xml_find_all( node, "LINE" ) ),
collapse = " "
)
c( speaker_v, receiver_v, lines_v )
}
# make the function better by restructuring what data are pulled
get_pairing <- function( node ){
speaker_v <- xml_text( xml_find_all( node, "SPEAKER" ) )
receiver_v <- xml_text( xml_find_all( node, "RECEIVER" ) )
lines_v <- paste(
xml_text( xml_find_all( node, "LINE" ) ),
collapse = " "
)
c( speaker_v, receiver_v, lines_v )
}
get_pairing( speeches_ns )
get_pairing( speeches_ns )[1]
get_pairing( speeches_ns )[[1]]
get_pairing( speeches_ns[[1]] )
speeches_ns[[255]]
